<?php

/**
 * Generated by PHPUnit_SkeletonGenerator on 2016-02-10 at 15:38:32.
 *
 * @requires extension mongo
 */
class Swift_MongoSpoolTest extends MongoTestCase
{
    /**
     * @covers Swift_MongoSpool::__construct
     * @covers Swift_MongoSpool::isStarted
     */
    public function testIsStarted()
    {
        $object = new Swift_MongoSpool($this->getMockBuilder('MongoCollection')->disableOriginalConstructor()->getMock());
        $this->assertTrue($object->isStarted());
    }

    /**
     * @covers Swift_MongoSpool::start
     * @covers Swift_MongoSpool::stop
     */
    public function testStop()
    {
        $object = new Swift_MongoSpool($this->getMockBuilder('MongoCollection')->disableOriginalConstructor()->getMock());
        // basically a no-op, just doing this for code coverage
        $object->start();
        $object->stop();
    }

    /**
     * @covers Swift_MongoSpool::queueMessage
     */
    public function testQueueMessage()
    {
        $body = 'Here is the message itself';
        $message = Swift_Message::newInstance()
          ->setSubject('Your subject')
          ->setFrom(array('john@doe.com' => 'John Doe'))
          ->setTo(array('receiver@domain.org'))
          ->setBody($body);
        
        $coll = $this->getMockBuilder('MongoCollection')->disableOriginalConstructor()->getMock();
        $coll->expects($this->once())
            ->method('insert')
            ->with($this->equalTo(array('message' => new \MongoBinData(serialize($message), 0))))
            ->willReturn(true);
        
        $object = new Swift_MongoSpool($coll);
        $this->assertTrue($object->queueMessage($message));
        
        $this->verifyMockObjects();
    }

    /**
     * @covers Swift_MongoSpool::recover
     * @covers Swift_MongoSpool::write
     */
    public function testRecover()
    {
        $coll = $this->getMockBuilder('MongoCollection')->disableOriginalConstructor()->getMock();
        $coll->expects($this->once())
            ->method('update')
            ->with(
                $this->equalTo(array('sentOn' => array('$lte' => new \MongoDate(time() - 900)))),
                $this->equalTo(array('$set' => array('sentOn' => null))),
                $this->equalTo(array('multiple' => true))
            )
            ->willReturn(true);
        
        $object = new Swift_MongoSpool($coll);
        $object->recover();
        
        $this->verifyMockObjects();
    }

    /**
     * @covers Swift_MongoSpool::flushQueue
     * @covers Swift_MongoSpool::write
     */
    public function testFlushQueue()
    {
        $body = 'Here is the message itself';
        $message1 = Swift_Message::newInstance()
          ->setSubject('Your subject 1')
          ->setFrom(array('john@doe.com' => 'John Doe'))
          ->setTo(array('receiver@domain.org'))
          ->setBody($body . ' 1');
        $message2 = Swift_Message::newInstance()
          ->setSubject('Your subject 2')
          ->setFrom(array('john@doe.com' => 'John Doe'))
          ->setTo(array('receiver@domain.org'))
          ->setBody($body . ' 2');
        
        $id1 = new \MongoId();
        $id2 = new \MongoId();
        $coll = $this->getMockBuilder('MongoCollection')->disableOriginalConstructor()->getMock();
        $coll->expects($this->once())
            ->method('find')
            ->with($this->equalTo(array('sentOn' => null)))
            ->willReturn(array(
                array('_id' => $id1, 'message' => new MongoBinData(serialize($message1), 0)),
                array('_id' => $id2, 'message' => new MongoBinData(serialize($message2), 0))
            ));
        $coll->expects($this->exactly(2))
            ->method('update')
            ->willReturn(true);
        $coll->expects($this->exactly(2))
            ->method('remove')
            ->willReturn(true);
        
        $failed = array();

        $transport = $this->getMockBuilder('Swift_Transport')->getMock();
        $transport->method('isStarted')->willReturn(true);
        $transport->expects($this->exactly(2))
            ->method('send')
            ->withConsecutive(
                array($this->equalTo($message1), $this->equalTo($failed)),
                array($this->equalTo($message2), $this->equalTo($failed))
            )->willReturn(1);
        
        $object = new Swift_MongoSpool($coll);
        $object->flushQueue($transport, $failed);
        
        $this->verifyMockObjects();
    }
}
