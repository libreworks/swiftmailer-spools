<?php

/**
 * Generated by PHPUnit_SkeletonGenerator on 2016-02-10 at 20:12:59.
 */
class Swift_PdoSpoolTest extends PHPUnit_Framework_TestCase
{
    /**
     * @covers Swift_PdoSpool::__construct
     * @covers Swift_PdoSpool::isStarted
     */
    public function testIsStarted()
    {
        $object = new Swift_PdoSpool($this->getMock('MockPdo'), 'foo', 'bar', 'message', 'sent');
        $this->assertTrue($object->isStarted());
    }

    /**
     * @covers Swift_PdoSpool::__construct
     * @covers Swift_PdoSpool::checkBlank
     * @expectedException \InvalidArgumentException
     */
    public function testBadConstruct()
    {
        new Swift_PdoSpool($this->getMock('MockPdo'), 'foo', 'bar', 'message', "     ");
    }
    
    /**
     * @covers Swift_PdoSpool::start
     * @covers Swift_PdoSpool::stop
     */
    public function testStart()
    {
        $object = new Swift_PdoSpool($this->getMock('MockPdo'), 'foo', 'bar', 'message', 'sent');
        // basically a no-op, just doing this for code coverage
        $object->start();
        $object->stop();
    }

    /**
     * @covers Swift_PdoSpool::queueMessage
     */
    public function testQueueMessage()
    {
        $body = 'Here is the message itself';
        $message = Swift_Message::newInstance()
            ->setSubject('Your subject')
            ->setFrom(array('john@doe.com' => 'John Doe'))
            ->setTo(array('receiver@domain.org'))
            ->setBody($body);
        
        $pdo = $this->getMock('MockPdo', array('prepare'));
        $stmt = $this->getMock('MockPdoStatement', array('bindValue', 'execute'));
        $pdo->expects($this->once())
            ->method('prepare')
            ->with($this->equalTo("INSERT INTO foo (message) VALUES (?)"))
            ->willReturn($stmt);
        $stmt->expects($this->once())
            ->method('bindValue')
            ->with($this->equalTo(1), $this->equalTo(serialize($message)), $this->equalTo(PDO::PARAM_STR));
        $stmt->expects($this->once())
            ->method('execute');
        
        $object = new Swift_PdoSpool($pdo, 'foo', 'bar', 'message', 'sent');
        $object->queueMessage($message);
        
        $this->verifyMockObjects();
    }

    /**
     * @covers Swift_PdoSpool::recover
     */
    public function testRecover()
    {
        $pdo = $this->getMock('MockPdo', array('prepare'));
        $stmt = $this->getMock('MockPdoStatement', array('bindValue', 'execute'));
        $pdo->expects($this->once())
            ->method('prepare')
            ->with($this->equalTo("UPDATE foo SET sent = NULL WHERE sent <= ?"))
            ->willReturn($stmt);
        $stmt->expects($this->once())
            ->method('bindValue')
            ->with($this->equalTo(1), $this->isType('int'), $this->equalTo(PDO::PARAM_INT));
        $stmt->expects($this->once())
            ->method('execute');
        
        $object = new Swift_PdoSpool($pdo, 'foo', 'bar', 'message', 'sent');
        $object->recover();
        
        $this->verifyMockObjects();
    }

    /**
     * @covers Swift_PdoSpool::flushQueue
     */
    public function testFlushQueue()
    {
        $body = 'Here is the message itself';
        $message1 = Swift_Message::newInstance()
          ->setSubject('Your subject 1')
          ->setFrom(array('john@doe.com' => 'John Doe'))
          ->setTo(array('receiver@domain.org'))
          ->setBody($body . ' 1');
        $message2 = Swift_Message::newInstance()
          ->setSubject('Your subject 2')
          ->setFrom(array('john@doe.com' => 'John Doe'))
          ->setTo(array('receiver@domain.org'))
          ->setBody($body . ' 2');
        
        $pdo = $this->getMock('MockPdo', array('prepare', 'query'));
        $stmta = $this->getMock('MockPdoStatement', array('fetchAll'));
        $stmtb = $this->getMock('MockPdoStatement', array('execute'));
        $stmtc = $this->getMock('MockPdoStatement', array('execute'));
        $pdo->expects($this->once())
            ->method('query')
            ->with($this->equalTo("SELECT bar as pkey, message as email FROM foo WHERE sent IS NULL"))
            ->willReturn($stmta);
        $pdo->expects($this->exactly(2))
            ->method('prepare')
            ->withConsecutive(
                array($this->equalTo('UPDATE foo SET sent = ? WHERE bar = ?')),
                array($this->equalTo('DELETE FROM foo WHERE bar = ?'))
            )
            ->willReturnOnConsecutiveCalls($stmtb, $stmtc);
        $stmta->expects($this->once())
            ->method('fetchAll')
            ->with($this->equalTo(PDO::FETCH_COLUMN))
            ->willReturn(array(
                array(1, serialize($message1)),
                array(2, serialize($message2))
            ));
        $stmtb->expects($this->exactly(2))
            ->method('execute');
        $stmtc->expects($this->exactly(2))
            ->method('execute')
            ->withConsecutive(
                array($this->equalTo(array(1))),
                array($this->equalTo(array(2)))
            );
        
        $failed = array();

        $transport = $this->getMockBuilder('Swift_Transport')->getMock();
        $transport->method('isStarted')->willReturn(true);
        $transport->expects($this->exactly(2))
            ->method('send')
            ->withConsecutive(
                array($this->equalTo($message1), $this->equalTo($failed)),
                array($this->equalTo($message2), $this->equalTo($failed))
            )->willReturn(1);
        
        $object = new Swift_PdoSpool($pdo, 'foo', 'bar', 'message', 'sent');
        $object->flushQueue($transport, $failed);
        
        $this->verifyMockObjects();
    }
}

class MockPdo extends \PDO
{
    public function __construct()
    {
    }
}

class MockPdoStatement extends \PDOStatement
{
    public function __construct()
    {
    }
}